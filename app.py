import streamlit as st
import re

# è®¾ç½®é¡µé¢é…ç½®
st.set_page_config(page_title="å…¨èƒ½å·¥ç¨‹æŸ¥è¯¢åŠ©æ‰‹ v2.6", page_icon="ğŸ› ï¸", layout="wide")

st.title("ğŸ› ï¸ å…¨èƒ½å·¥ç¨‹æŸ¥è¯¢åŠ©æ‰‹")
st.markdown("é›†æˆï¼š**æ™ºèƒ½é”®æ§½å…¬å·®æŸ¥è¯¢** | **ISO 286 å…¬å·®æŸ¥è¯¢**")

# åˆ›å»º 2 ä¸ªé€‰é¡¹å¡
tab1, tab2 = st.tabs([
    "ğŸ” é”®æ§½å…¬å·®æŸ¥è¯¢", 
    "ğŸ“ ISO 286 å…¬å·®"
])

# ==============================================================================
# å…¨å±€æ•°æ®åº“
# ==============================================================================

# 1. å…¬åˆ¶é”®æ§½æ•°æ® (DIN 6885 / ISO 773)
# [Min_Shaft, Max_Shaft, Spec, W, W_tol, Hub_Depth_Min, Hub_Depth_Max, R_min, R_max]
METRIC_DB = [
    (6, 8, "2x2", 2, 0.0125, 1.0, 1.1, 0.08, 0.16),
    (8, 10, "3x3", 3, 0.0125, 1.4, 1.5, 0.08, 0.16),
    (10, 12, "4x4", 4, 0.015, 1.8, 1.9, 0.08, 0.16),
    (12, 17, "5x5", 5, 0.015, 2.3, 2.4, 0.16, 0.25),
    (17, 22, "6x6", 6, 0.015, 2.8, 2.9, 0.16, 0.25),
    (22, 30, "8x7", 8, 0.018, 3.3, 3.5, 0.16, 0.25),
    (30, 38, "10x8", 10, 0.018, 3.3, 3.5, 0.25, 0.40),
    (38, 44, "12x8", 12, 0.0215, 3.3, 3.5, 0.25, 0.40),
    (44, 50, "14x9", 14, 0.0215, 3.8, 4.0, 0.25, 0.40),
    (50, 58, "16x10", 16, 0.0215, 4.3, 4.5, 0.25, 0.40),
    (58, 65, "18x11", 18, 0.0215, 4.4, 4.6, 0.25, 0.40),
    (65, 75, "20x12", 20, 0.026, 4.9, 5.1, 0.40, 0.60),
    (75, 85, "22x14", 22, 0.026, 5.4, 5.6, 0.40, 0.60),
    (85, 95, "25x14", 25, 0.026, 5.4, 5.6, 0.40, 0.60),
    (95, 110, "28x16", 28, 0.026, 6.4, 6.6, 0.40, 0.60)
]

# 2. è‹±åˆ¶é”®æ§½æ•°æ® (ANSI B17.1 Square Keys - Class 2 Fit)
# [Shaft_Min, Shaft_Max, Key_Width(Nominal), Hub_Depth_Min(Nominal)]
IMPERIAL_DB_ANSI = [
    (0.3125, 0.4375, 0.09375, 0.0469), # 5/16 - 7/16 -> 3/32 Key
    (0.4375, 0.5625, 0.12500, 0.0625), # 7/16 - 9/16 -> 1/8 Key
    (0.5625, 0.8750, 0.18750, 0.0938), # 9/16 - 7/8  -> 3/16 Key
    (0.8750, 1.2500, 0.25000, 0.1250), # 7/8 - 1-1/4 -> 1/4 Key
    (1.2500, 1.3750, 0.31250, 0.1563), # 1-1/4 - 1-3/8 -> 5/16 Key
    (1.3750, 1.7500, 0.37500, 0.1875), # 1-3/8 - 1-3/4 -> 3/8 Key
    (1.7500, 2.2500, 0.50000, 0.2500), # 1-3/4 - 2-1/4 -> 1/2 Key
    (2.2500, 2.7500, 0.62500, 0.3125), # 2-1/4 - 2-3/4 -> 5/8 Key
    (2.7500, 3.2500, 0.75000, 0.3750), # 2-3/4 - 3-1/4 -> 3/4 Key
    (3.2500, 3.7500, 0.87500, 0.4375), # 3-1/4 - 3-3/4 -> 7/8 Key
    (3.7500, 4.5000, 1.00000, 0.5000), # 3-3/4 - 4-1/2 -> 1 Key
    (4.5000, 5.5000, 1.25000, 0.6250), # 4-1/2 - 5-1/2 -> 1-1/4 Key
    (5.5000, 6.5000, 1.50000, 0.7500), # 5-1/2 - 6-1/2 -> 1-1/2 Key
]

# ==============================================================================
# TAB 1: é”®æ§½å…¬å·®æŸ¥è¯¢
# ==============================================================================
with tab1:
    st.header("ğŸ” é”®æ§½å…¬å·®æŸ¥è¯¢")
    st.caption("è¾“å…¥ç¤ºä¾‹: **8JS9** (å…¬åˆ¶) æˆ– **0.25**, **1/4** (è‹±åˆ¶)")

    unit_mode = st.radio("é€‰æ‹©å•ä½ä½“ç³»", ["å…¬åˆ¶ (Metric)", "è‹±åˆ¶ (Imperial)"], horizontal=True)
    col_input, col_btn = st.columns([3, 1])

    # --- å…¬åˆ¶é€»è¾‘ ---
    if unit_mode == "å…¬åˆ¶ (Metric)":
        with col_input:
            user_input = st.text_input("è¾“å…¥è§„æ ¼ä»£ç  (å¦‚ 8JS9, 10P9)", value="8JS9")
        
        match = re.match(r"(\d+)(.*)", user_input.strip())
        if match:
            size_nom = int(match.group(1))
            tol_class = match.group(2).upper()
            if not tol_class: tol_class = "h9"

            st.divider()
            
            # IT9 rough lookup
            it9_lookup = {
                (0, 3): 25, (3, 6): 30, (6, 10): 36, (10, 18): 43, 
                (18, 30): 52, (30, 50): 62, (50, 80): 74
            }
            it_val = 0
            for r, val in it9_lookup.items():
                if r[0] < size_nom <= r[1]:
                    it_val = val
                    break
            
            upper, lower = 0, 0
            is_valid_tol = True
            
            if tol_class == "JS9":
                upper = it_val / 2 / 1000; lower = -it_val / 2 / 1000
            elif tol_class == "P9":
                offset = -it_val / 1000 
                if size_nom <= 3: offset = -0.006 
                elif size_nom <= 6: offset = -0.012
                elif size_nom <= 10: offset = -0.015
                elif size_nom <= 18: offset = -0.018
                elif size_nom <= 30: offset = -0.022
                else: offset = -0.026
                upper = offset; lower = offset - (it_val / 1000)
            elif tol_class == "N9":
                upper = 0; lower = -(it_val / 1000)
            elif tol_class == "H9":
                upper = it_val / 1000; lower = 0
            else:
                st.warning(f"æš‚ä¸æ”¯æŒå…¬å·® {tol_class} çš„è‡ªåŠ¨è®¡ç®—ã€‚")
                is_valid_tol = False

            c1, c2, c3 = st.columns(3)
            c1.metric(f"é”®å®½ ({size_nom} {tol_class})", f"{size_nom:.2f} mm")
            if is_valid_tol:
                c2.metric("æœ€å¤§æé™", f"{size_nom + upper:.3f} mm", f"{upper*1000:+.0f} Î¼m")
                c3.metric("æœ€å°æé™", f"{size_nom + lower:.3f} mm", f"{lower*1000:+.0f} Î¼m")
            
            st.subheader("ğŸ“ å…³è”æ ‡å‡†å°ºå¯¸ (DIN 6885)")
            found_spec = False
            for row in METRIC_DB:
                if row[3] == size_nom:
                    found_spec = True
                    with st.expander(f"åŒ¹é…è§„æ ¼: {row[2]} (é€‚ç”¨è½´å¾„ Ã˜{row[0]}-{row[1]}mm)", expanded=True):
                        kc1, kc2, kc3 = st.columns(3)
                        kc1.write(f"**é”®å®½:** {row[3]} mm")
                        kc2.write(f"**é”®é«˜:** {row[2].split('x')[1]} mm")
                        # ä¿®æ”¹åç§°ï¼šè½®æ¯‚æ§½æ·± -> é”®æ·±
                        kc3.write(f"**é”®æ·± (Key Depth):** {row[5]}~{row[6]} mm")
            if not found_spec:
                st.info("æœªæ‰¾åˆ°æ ‡å‡†é”®è§„æ ¼")
    
    # --- è‹±åˆ¶é€»è¾‘ ---
    else:
        with col_input:
            user_input_imp = st.text_input("è¾“å…¥è‹±åˆ¶é”®å®½ (å¦‚ 0.25 æˆ– 1/4)", value="0.25")
        
        try:
            # è§£æè¾“å…¥
            if "/" in user_input_imp:
                n, d = user_input_imp.split("/")
                val_imp = float(n)/float(d)
            else:
                val_imp = float(user_input_imp)
            
            val_mm_nom = val_imp * 25.4

            # ANSI B17.1 Class 2 Fit Tolerance
            tol_imp_upper = 0.0020
            if val_imp > 0.75: tol_imp_upper = 0.0030
            
            tol_mm_upper = tol_imp_upper * 25.4 # è½¬æ¢å…¬å·®å€¼ä¸ºmm

            st.divider()
            
            # 1. æ˜¾ç¤ºä¸‰æ 
            ic1, ic2, ic3 = st.columns(3)
            
            ic1.metric("è‹±åˆ¶é”®å®½ (Nominal)", 
                       f"{val_imp:.4f}\"", 
                       f"{val_mm_nom:.3f} mm", delta_color="off")
            
            # æ˜¾ç¤º mm
            ic2.metric("æœ€å¤§æé™ (Max)", 
                       f"{(val_imp + tol_imp_upper):.4f}\"", 
                       f"+{tol_imp_upper}\" (+{tol_mm_upper:.3f} mm)")

            ic3.metric("æœ€å°æé™ (Min)", 
                       f"{val_imp:.4f}\"", 
                       f"-0.0000\" (0.000 mm)")

            # 2. å…³è”æ ‡å‡†å°ºå¯¸
            st.subheader("ğŸ“ å…³è”æ ‡å‡†å°ºå¯¸ (ANSI B17.1)")
            
            found_imp_spec = False
            for row in IMPERIAL_DB_ANSI:
                # row[2] is Key Width
                if abs(val_imp - row[2]) < 0.005:
                    found_imp_spec = True
                    shaft_range_str = f"{row[0]:.4f}\" ~ {row[1]:.4f}\""
                    
                    # Hub Depth Logic (Range Calculation)
                    depth_min = row[3]
                    # ANSI B17.1: Tolerance +0.010 for shafts up to 1-3/4", +0.015 for larger
                    depth_tol = 0.010
                    if row[1] > 1.75: depth_tol = 0.015
                    depth_max = depth_min + depth_tol

                    # Conversions
                    w_mm = row[2] * 25.4
                    h_mm = row[2] * 25.4 # Square key H=W
                    d_mm_min = depth_min * 25.4
                    d_mm_max = depth_max * 25.4

                    with st.expander(f"åŒ¹é…è§„æ ¼: Square Key (é€‚ç”¨è½´å¾„ {shaft_range_str})", expanded=True):
                        kc1, kc2, kc3 = st.columns(3)
                        kc1.write(f"**é”®å®½ (Width):** {row[2]:.4f}\" ({w_mm:.3f} mm)")
                        kc2.write(f"**é”®é«˜ (Height):** {row[2]:.4f}\" ({h_mm:.3f} mm)") 
                        
                        # ä¿®æ”¹åç§°ï¼šè½®æ¯‚æ§½æ·± -> é”®æ·±ï¼Œå¹¶æ˜¾ç¤ºä¸ºèŒƒå›´
                        kc3.write(f"**é”®æ·± (Key Depth):**")
                        kc3.code(f"{depth_min:.4f}\" ~ {depth_max:.4f}\"\n({d_mm_min:.2f} ~ {d_mm_max:.2f} mm)")
                    break

            if not found_imp_spec:
                st.warning("âš ï¸ è¾“å…¥çš„å°ºå¯¸ä¸æ˜¯ ANSI B17.1 æ ‡å‡†æ–¹é”®å®½åº¦ï¼Œæœªæ‰¾åˆ°å…³è”è½´å¾„æ•°æ®ã€‚")

        except Exception as e:
             st.error("è¾“å…¥æ ¼å¼æœ‰è¯¯ï¼Œè¯·è¾“å…¥å°æ•°(0.25)æˆ–åˆ†æ•°(1/4)ã€‚")

# ==============================================================================
# TAB 2: ISO 286 å…¬å·®æŸ¥è¯¢
# ==============================================================================
with tab2:
    st.header("ISO 286 å…¬å·®æŸ¥è¯¢")
    st.caption("æ”¯æŒå…¬å·®å¸¦ï¼šH7, H8, F7, F8, G7, K7, P7, h7, h8, h12, h14, g8")

    RANGES_ISO = [3, 6, 10, 18, 30, 50, 80, 120, 180, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600, 2000, 2500, 3150]
    DATA_TABLE_ISO = {
        "H7": [0.010, 0.012, 0.015, 0.018, 0.021, 0.025, 0.030, 0.035, 0.040, 0.046, 0.052, 0.057, 0.063, 0.070, 0.080, 0.090, 0.105, 0.125, 0.150, 0.175, 0.210],
        "H8": [0.014, 0.018, 0.022, 0.027, 0.033, 0.039, 0.046, 0.054, 0.063, 0.072, 0.081, 0.089, 0.097, 0.110, 0.125, 0.140, 0.165, 0.195, 0.230, 0.280, 0.330],
        "F7": [(0.016, 0.006), (0.022, 0.010), (0.028, 0.013), (0.034, 0.016), (0.041, 0.020), (0.050, 0.025), (0.060, 0.030), (0.071, 0.036), (0.083, 0.043), (0.096, 0.050), (0.108, 0.056), (0.119, 0.062), (0.131, 0.068), (0.150, 0.080), (0.170, 0.090), (0.190, 0.100), (0.220, 0.115), (0.260, 0.135), (0.310, 0.160), (0.365, 0.190), (0.440, 0.230)],
        "F8": [(0.020, 0.006), (0.028, 0.010), (0.035, 0.013), (0.043, 0.016), (0.053, 0.020), (0.064, 0.025), (0.076, 0.030), (0.090, 0.036), (0.106, 0.043), (0.122, 0.050), (0.137, 0.056), (0.151, 0.062), (0.165, 0.068), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)],
        "G7": [(0.012, 0.002), (0.016, 0.004), (0.020, 0.005), (0.024, 0.006), (0.028, 0.007), (0.034, 0.009), (0.040, 0.010), (0.047, 0.012), (0.054, 0.014), (0.061, 0.015), (0.069, 0.017), (0.075, 0.018), (0.083, 0.020), (0.096, 0.026), (0.108, 0.028), (0.122, 0.032), (0.141, 0.036), (0.167, 0.042), (0.200, 0.050), (0.235, 0.060), (0.280, 0.070)],
        "K7": [(0.000, -0.010), (0.003, -0.009), (0.005, -0.010), (0.006, -0.012), (0.006, -0.015), (0.007, -0.018), (0.009, -0.021), (0.010, -0.025), (0.012, -0.028), (0.013, -0.033), (0.016, -0.036), (0.017, -0.040), (0.018, -0.045), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)],
        "P7": [(-0.006, -0.016), (-0.008, -0.020), (-0.009, -0.024), (-0.011, -0.029), (-0.014, -0.035), (-0.017, -0.042), (-0.021, -0.051), (-0.024, -0.059), (-0.028, -0.068), (-0.033, -0.079), (-0.036, -0.088), (-0.041, -0.098), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)],
        "h7": [0.010, 0.012, 0.015, 0.018, 0.021, 0.025, 0.030, 0.035, 0.040, 0.046, 0.052, 0.057, 0.063, 0.070, 0.080, 0.090, 0.105, 0.125, 0.150, 0.175, 0.210],
        "h8": [0.014, 0.018, 0.022, 0.027, 0.033, 0.039, 0.046, 0.054, 0.063, 0.072, 0.081, 0.089, 0.097, 0.110, 0.125, 0.140, 0.165, 0.195, 0.230, 0.280, 0.330],
        "h12": [0.10, 0.12, 0.15, 0.18, 0.21, 0.25, 0.30, 0.35, 0.40, 0.46, 0.52, 0.57, 0.63, 0.70, 0.80, 0.90, 1.05, 1.25, 1.50, 1.75, 2.10],
        "h14": [0.25, 0.30, 0.36, 0.43, 0.52, 0.62, 0.74, 0.87, 1.0, 1.15, 1.3, 1.4, 1.55, 1.75, 2.0, 2.3, 2.6, 3.1, 3.7, 4.4, 5.4],
        "g8": [(-0.002, -0.016), (-0.004, -0.022), (-0.005, -0.027), (-0.006, -0.033), (-0.007, -0.040), (-0.009, -0.048), (-0.010, -0.056), (-0.012, -0.066), (-0.014, -0.077), (-0.015, -0.087), (-0.017, -0.098), (-0.018, -0.107), (-0.020, -0.117), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)]
    }

    col1, col2 = st.columns([3, 1])
    with col1:
        iso_size = st.number_input("è¾“å…¥å…¬ç§°å°ºå¯¸ (mm)", 0.1, 3150.0, 50.0, 10.0)
    with col2:
        iso_code = st.selectbox("å…¬å·®å¸¦", ["H7", "H8", "F7", "F8", "G7", "K7", "P7", "h7", "h8", "h12", "h14", "g8"])

    if st.button("æŸ¥è¯¢ ISO", type="primary"):
        idx = -1
        prev = 0
        for i, r in enumerate(RANGES_ISO):
            if iso_size <= r:
                idx = i; break
            prev = r
        
        if idx != -1 and iso_code in DATA_TABLE_ISO:
            val = DATA_TABLE_ISO[iso_code][idx]
            is_empty = False
            if isinstance(val, tuple):
                if val == (0,0): is_empty = True
                u, l = val
            elif iso_code[0] == 'H': u, l = val, 0
            else: u, l = 0, -val
            
            if is_empty:
                st.error(f"âš ï¸ {iso_code} åœ¨å°ºå¯¸ {iso_size}mm å¤„æš‚æ— æ ‡å‡†æ•°æ®ã€‚")
            else:
                st.success(f"âœ… {iso_code} (Ã˜{iso_size}mm)")
                c1, c2, c3 = st.columns(3)
                c1.metric("Max", f"{iso_size+u:.3f}")
                c2.metric("Min", f"{iso_size+l:.3f}")
                c3.metric("IT", f"{(u-l)*1000:.0f} Î¼m" if (u-l)<1 else f"{(u-l):.2f} mm")
                st.info(f"åå·®: {u*1000:+.0f}/{l*1000:+.0f} Î¼m" if abs(u)<1 else f"{u:+.3f}/{l:+.3f} mm")
        else:
            st.error("æœªæ‰¾åˆ°æ•°æ®æˆ–å°ºå¯¸è¶…å‡ºèŒƒå›´")
